```{julia}
include("notebooks/setup.jl")
eval(setup_notebooks)
```

# MNIST

## Anecdotal Evidence

### Examples in Introduction

#### Wachter and JSMA

```{julia}
# Data:
counterfactual_data = load_mnist()
X, y = CounterfactualExplanations.DataPreprocessing.unpack_data(counterfactual_data)
input_dim, n_obs = size(counterfactual_data.X)
M = load_mnist_mlp()

# Target:
factual_label = 8
x = reshape(X[:,rand(findall(predict_label(M, counterfactual_data).==factual_label))],input_dim,1)
target = 3
factual = predict_label(M, counterfactual_data, x)[1]
Œ≥ = 0.9
T = 50
```

```{julia}
# Search:
opt = Flux.Optimise.Adam(0.01)
generator = GenericGenerator(opt=opt)
ce_wachter = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
)
generator = GreedyGenerator(Œ∑=1.0)
ce_jsma = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
)
```

```{julia}
p1 = Plots.plot(
    convert2image(MNIST, reshape(x,28,28)),
    axis=nothing, 
    size=(img_height, img_height),
    title="Factual"
)
plts = [p1]

ces = zip([ce_wachter,ce_jsma])
counterfactuals = reduce((x,y)->cat(x,y,dims=3),map(ce -> CounterfactualExplanations.counterfactual(ce[1]), ces))
phat = reduce((x,y) -> cat(x,y,dims=3), map(ce -> target_probs(ce[1]), ces))
for x in zip(eachslice(counterfactuals; dims=3), eachslice(phat; dims=3), ["Wachter","JSMA"])
    ce, _phat, _name = (x[1],x[2],x[3])
    _title = "$(_name) (p=$(round(_phat[1]; digits=2)))"
    plt = Plots.plot(
        convert2image(MNIST, reshape(ce,28,28)),
        axis=nothing, 
        size=(img_height, img_height),
        title=_title
    )
    plts = [plts..., plt]
end
plt = Plots.plot(plts...; size=(img_height*length(plts),img_height), layout=(1,length(plts)))
display(plt)
savefig(plt, joinpath(www_path, "you_may_not_like_it.png"))
```

#### REVISE

```{julia}
using CounterfactualExplanations.Models: load_mnist_vae
vae = load_mnist_vae()
vae_weak = load_mnist_vae(;strong=false)
Serialization.serialize(joinpath(output_path,"mnist_classifier.jls"), M)
Serialization.serialize(joinpath(output_path,"mnist_vae.jls"), vae)
Serialization.serialize(joinpath(output_path,"mnist_vae_weak.jls"), vae_weak)
```

```{julia}
# Define generator:
generator = REVISEGenerator(
  opt = opt,
  Œª=0.01
)
# Generate recourse:
counterfactual_data.generative_model = vae # assign generative model
ce_strong = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
)
counterfactual_data = deepcopy(counterfactual_data)
counterfactual_data.generative_model = vae_weak
ce_weak = generate_counterfactual(
    x, target, counterfactual_data, M, generator;
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
)
```

```{julia}
ces = zip([ce_strong,ce_weak])
counterfactuals = reduce((x,y)->cat(x,y,dims=3),map(ce -> CounterfactualExplanations.counterfactual(ce[1]), ces))
phat = reduce((x,y) -> cat(x,y,dims=3), map(ce -> target_probs(ce[1]), ces))
plts = [p1]
for x in zip(eachslice(counterfactuals; dims=3), eachslice(phat; dims=3), ["Strong VAE","Weak VAE"])
    ce, _phat, _name = (x[1],x[2],x[3])
    _title = "$(_name) (p=$(round(_phat[1]; digits=2)))"
    plt = Plots.plot(
        convert2image(MNIST, reshape(ce,28,28)),
        axis=nothing, 
        size=(img_height, img_height),
        title=_title
    )
    plts = [plts..., plt]
end
plt = Plots.plot(plts...; size=(img_height*length(plts),img_height), layout=(1,length(plts)))
display(plt)
savefig(plt, joinpath(www_path, "surrogate_gone_wrong.png"))
```

### ECCCo

```{julia}
function pre_process(x; noise::Float32=0.03f0)
    œµ = Float32.(randn(size(x)) * noise)
    x = @.(2 * x - 1) .+ œµ
    return x
end
```

```{julia}
# Data:
n_obs = 1000
counterfactual_data = load_mnist(n_obs)
counterfactual_data.X = pre_process.(counterfactual_data.X)
X, y = CounterfactualExplanations.DataPreprocessing.unpack_data(counterfactual_data)
X = table(permutedims(X))
labels = counterfactual_data.output_encoder.labels
input_dim, n_obs = size(counterfactual_data.X)
n_digits = Int(sqrt(input_dim))
output_dim = length(unique(labels))
```

First, let's create a couple of image classifier architectures:

```{julia}
# Model parameters:
epochs = 100
batch_size = minimum([Int(round(n_obs/10)), 128])
n_hidden = 128
activation = Flux.relu
builder = MLJFlux.@builder Flux.Chain(
    Dense(n_in, n_hidden, activation),
    Dense(n_hidden, n_out),
)
n_ens = 5                                   # number of models in ensemble
_loss = Flux.Losses.logitcrossentropy       # loss function
_finaliser = x -> x                         # finaliser function
```

```{julia}
# JEM parameters:
ùíüx = Uniform(-1,1)
ùíüy = Categorical(ones(output_dim) ./ output_dim)
sampler = ConditionalSampler(
    ùíüx, ùíüy, 
    input_size=(input_dim,), 
    batch_size=1,
)
Œ± = [1.0,1.0,1e-2]      # penalty strengths
```

```{julia}
# Simple MLP:
mlp = NeuralNetworkClassifier(
    builder=builder, 
    epochs=epochs,
    batch_size=batch_size,
    finaliser=_finaliser,
    loss=_loss,
)

# Deep Ensemble:
mlp_ens = EnsembleModel(model=mlp, n=n_ens)

# Joint Energy Model:
jem = JointEnergyClassifier(
    sampler;
    builder=builder,
    epochs=epochs,
    batch_size=batch_size,
    finaliser=_finaliser,
    loss=_loss,
    jem_training_params=(
        Œ±=Œ±,verbosity=10,
    ),
    sampling_steps=20,
)

# JEM with adversarial training:
jem_adv = deepcopy(jem)
# jem_adv.adv_training = true

# Deep Ensemble of Joint Energy Models:
jem_ens = EnsembleModel(model=jem, n=n_ens)

# Deep Ensemble of Joint Energy Models with adversarial training:
# jem_ens_plus = EnsembleModel(model=jem_adv, n=n_ens)

# Dictionary of models:
models = Dict(
    "MLP" => mlp,
    "MLP Ensemble" => mlp_ens,
    "JEM" => jem,
    "JEM Ensemble" => jem_ens,
    # "JEM Ensemble+" => jem_ens_plus,
)
```


```{julia}
# Train models:
function _train(model, X=X, y=labels; cov=.95, method=:simple_inductive, mod_name="model")
    conf_model = conformal_model(model; method=method, coverage=cov)
    mach = machine(conf_model, X, y)
    @info "Begin training $mod_name."
    fit!(mach)
    @info "Finished training $mod_name."
    M = ECCCo.ConformalModel(mach.model, mach.fitresult)
    return M
end
model_dict = Dict(mod_name => _train(mod; mod_name=mod_name) for (mod_name, mod) in models)
Serialization.serialize(joinpath(output_path,"mnist_models.jls"), model_dict)
```

```{julia}
for (mod_name, mod) in model_dict

    # Plot:
    if mod.model.model isa JointEnergyClassifier
        sampler = mod.model.model.jem.sampler
    elseif mod.model.model.model isa JointEnergyClassifier
        sampler = mod.model.model.model.jem.sampler
    else
        K = length(counterfactual_data.y_levels)
        input_size = size(selectdim(counterfactual_data.X, ndims(counterfactual_data.X), 1))
        ùíüx = Uniform(extrema(counterfactual_data.X)...)
        ùíüy = Categorical(ones(K) ./ K)
        sampler = ConditionalSampler(ùíüx, ùíüy; input_size=input_size)
    end
    opt = ImproperSGLD()
    f(x) = logits(mod, x)

    n_iter = 200
    _w = 1500
    plts = []
    neach = 10
    for i in 1:10
        x = sampler(f, opt; niter=n_iter, n_samples=neach, y=i)
        plts_i = []
        for j in 1:size(x, 2)
            xj = x[:,j]
            xj = reshape(xj, (n_digits, n_digits))
            plts_i = [plts_i..., Plots.heatmap(rotl90(xj), axis=nothing, cb=false)]
        end
        plt = Plots.plot(plts_i..., size=(_w,0.10*_w), layout=(1,10))
        plts = [plts..., plt]
    end
    plt = Plots.plot(plts..., size=(_w,_w), layout=(10,1), plot_title=mod_name)
    display(plt)

    # Test performance:
    test_data = load_mnist_test()
    test_data.X = pre_process.(test_data.X)
    f1 = CounterfactualExplanations.Models.model_evaluation(M, test_data)
    println("F1 score (test): $(round(f1,digits=3))")
end
```

```{julia}
Random.seed!(1234)

# Set up search:
factual_label = 9
x = reshape(counterfactual_data.X[:,rand(findall(predict_label(M, counterfactual_data).==factual_label))],input_dim,1)
target = 7
factual = predict_label(M, counterfactual_data, x)[1]
Œ≥ = 0.9
T = 100

Œ∑=1.0

# Generate counterfactual using generic generator:
generator = GenericGenerator(opt=Flux.Optimise.Adam(0.01),)
ce_wachter = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
    converge_when=:generator_conditions,
)

generator = GreedyGenerator(Œ∑=Œ∑)
ce_jsma = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
    converge_when=:generator_conditions,
)

# ECCCo:
Œª=[0.1,0.1,0.1]
temp=0.1

# Generate counterfactual using ECCCo generator:
generator = ECCCoGenerator(
    Œª=Œª, 
    temp=temp, 
    opt=Flux.Optimise.Adam(0.01),
)
ce_conformal = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
    converge_when=:generator_conditions,
)

# Generate counterfactual using ECCCo generator:
generator = ECCCoGenerator(
    Œª=Œª, 
    temp=temp, 
    opt=CounterfactualExplanations.Generators.JSMADescent(Œ∑=Œ∑),
)
ce_conformal_jsma = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
    converge_when=:generator_conditions,
)

# Plot:
p1 = Plots.plot(
    convert2image(MNIST, reshape(x,28,28)),
    axis=nothing, 
    size=(img_height, img_height),
    title="Factual"
)
plts = [p1]

ces = [ce_wachter, ce_conformal, ce_jsma, ce_conformal_jsma]
_names = ["Wachter", "ECCCo", "JSMA", "ECCCo-JSMA"]
for x in zip(ces, _names)
    ce, _name = (x[1],x[2])
    x = CounterfactualExplanations.counterfactual(ce)
    _phat = target_probs(ce)
    _title = "$_name (pÃÇ=$(round(_phat[1]; digits=3)))"
    plt = Plots.plot(
        convert2image(MNIST, reshape(x,28,28)),
        axis=nothing, 
        size=(img_height, img_height),
        title=_title
    )
    plts = [plts..., plt]
end
plt = Plots.plot(plts...; size=(img_height*length(plts),img_height), layout=(1,length(plts)))
display(plt)
savefig(plt, joinpath(www_path, "eccco_mnist.png"))
```

```{julia}
# Random.seed!(1234)

# Set up search:
factual_label = 8
x = reshape(counterfactual_data.X[:,rand(findall(predict_label(M, counterfactual_data).==factual_label))],input_dim,1)
target = 3
factual = predict_label(M, counterfactual_data, x)[1]
Œ≥ = 0.5
T = 100

# Generate counterfactual using generic generator:
generator = GenericGenerator(opt=Flux.Optimise.Adam(),)
ce_wachter = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
)

generator = GreedyGenerator(Œ∑=1.0)
ce_jsma = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
)

# ECCCo:
Œª=[0.0,1.0]
temp=0.5

# Generate counterfactual using CCE generator:
generator = CCEGenerator(
    Œª=Œª, 
    temp=temp, 
    opt=Flux.Optimise.Adam(),
)
ce_conformal = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
    converge_when=:generator_conditions,
)

# Generate counterfactual using CCE generator:
generator = CCEGenerator(
    Œª=Œª, 
    temp=temp, 
    opt=CounterfactualExplanations.Generators.JSMADescent(Œ∑=1.0),
)
ce_conformal_jsma = generate_counterfactual(
    x, target, counterfactual_data, M, generator; 
    decision_threshold=Œ≥, max_iter=T,
    initialization=:identity,
    converge_when=:generator_conditions,
)

# Plot:
p1 = Plots.plot(
    convert2image(MNIST, reshape(x,28,28)),
    axis=nothing, 
    size=(img_height, img_height),
    title="Factual"
)
plts = [p1]

ces = [ce_wachter, ce_conformal, ce_jsma, ce_conformal_jsma]
_names = ["Wachter", "CCE", "JSMA", "CCE-JSMA"]
for x in zip(ces, _names)
    ce, _name = (x[1],x[2])
    x = CounterfactualExplanations.counterfactual(ce)
    _phat = target_probs(ce)
    _title = "$_name (pÃÇ=$(round(_phat[1]; digits=3)))"
    plt = Plots.plot(
        convert2image(MNIST, reshape(x,28,28)),
        axis=nothing, 
        size=(img_height, img_height),
        title=_title
    )
    plts = [plts..., plt]
end
plt = Plots.plot(plts...; size=(img_height*length(plts),img_height), layout=(1,length(plts)))
display(plt)
savefig(plt, joinpath(www_path, "cce_mnist.png"))
```

```{julia}
if M.model.model isa JointEnergyModels.JointEnergyClassifier
    jem = M.model.model.jem
    n_iter = 200
    _w = 1500
    plts = []
    neach = 10
    for i in 1:10
        x = jem.sampler(jem.chain, jem.sampling_rule; niter=n_iter, n_samples=neach, y=i)
        plts_i = []
        for j in 1:size(x, 2)
            xj = x[:,j]
            xj = reshape(xj, (n_digits, n_digits))
            plts_i = [plts_i..., Plots.heatmap(rotl90(xj), axis=nothing, cb=false)]
        end
        plt = Plots.plot(plts_i..., size=(_w,0.10*_w), layout=(1,10))
        plts = [plts..., plt]
    end
    plt = Plots.plot(plts..., size=(_w,_w), layout=(10,1))
    display(plt)
end
```

## Benchmark

```{julia}
# Benchmark generators:
generators = Dict(
    :wachter => GenericGenerator(opt=opt, Œª=l2_Œª),
    :revise => REVISEGenerator(opt=opt, Œª=l2_Œª),
    :greedy => GreedyGenerator(),
)

# Conformal Models: 


# Measures:
measures = [
    CounterfactualExplanations.distance,
    ECCCo.distance_from_energy,
    ECCCo.distance_from_targets,
    CounterfactualExplanations.validity,
]
```