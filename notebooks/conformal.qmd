```{julia}
using CCE
using ConformalPrediction
using CounterfactualExplanations
using CounterfactualExplanations.Data
using CounterfactualExplanations.Objectives
using Flux
using LinearAlgebra
using MLJBase
using MLJFlux
using Plots
```

# `ConformalGenerator`

In this section, we will look at a simple example involving synthetic data, a black-box model and a generic Conformal Counterfactual Generator.

## Black-box Model

We consider a simple binary classification problem. Let $(X_i, Y_i), \ i=1,...,n$ denote our feature-label pairs and let $\mu: \mathcal{X} \mapsto \mathcal{Y}$ denote the mapping from features to labels. For illustration purposes, we will use linearly separable data. 

```{julia}
counterfactual_data = load_linearly_separable()
```

While we could use a linear classifier in this case, let's pretend we need a black-box model for this task and rely on a small Multi-Layer Perceptron (MLP):

```{julia}
builder = MLJFlux.@builder Chain(
    Dense(n_in, 32, relu),
    Dense(32, n_out)
)
clf = NeuralNetworkClassifier(builder=builder, epochs=100)
```

We can fit this model to data to produce plug-in predictions. 

### Split Conformal Classification

Here we will instead use a specific case of CP called *split conformal prediction* which can then be summarized as follows:^[In other places split conformal prediction is sometimes referred to as *inductive* conformal prediction.]

1. Partition the training into a proper training set and a separate calibration set: $\mathcal{D}_n=\mathcal{D}^{\text{train}} \cup \mathcal{D}^{\text{cali}}$.
2. Train the machine learning model on the proper training set: $\hat\mu_{i \in \mathcal{D}^{\text{train}}}(X_i,Y_i)$.

The model $\hat\mu_{i \in \mathcal{D}^{\text{train}}}$ can now produce plug-in predictions. 

::: callout-note

## Starting Point

Note that this represents the starting point in applications of Algorithmic Recourse: we have some pre-trained classifier $M$ for which we would like to generate plausible Counterfactual Explanations. Next, we turn to the calibration step. 
:::

3. Compute nonconformity scores, $\mathcal{S}$, using the calibration data $\mathcal{D}^{\text{cali}}$ and the fitted model $\hat\mu_{i \in \mathcal{D}^{\text{train}}}$. 
4. For a user-specified desired coverage ratio $(1-\alpha)$ compute the corresponding quantile, $\hat{q}$, of the empirical distribution of nonconformity scores, $\mathcal{S}$.
5. For the given quantile and test sample $X_{\text{test}}$, form the corresponding conformal prediction set: 

$$
C(X_{\text{test}})=\{y:s(X_{\text{test}},y) \le \hat{q}\}
$$ {#eq-set}

This is the default procedure used for classification and regression in [`ConformalPrediction.jl`](https://github.com/pat-alt/ConformalPrediction.jl). 

Using the package, we can apply Split Conformal Prediction as follows:

```{julia}
X = table(permutedims(counterfactual_data.X))
y =  counterfactual_data.output_encoder.labels
conf_model = conformal_model(clf; method=:simple_inductive)
mach = machine(conf_model, X, y)
fit!(mach)
```

To be clear, all of the calibration steps (3 to 5) are post hoc, and yet none of them involved any changes to the model parameters. These are two important characteristics of Split Conformal Prediction (SCP) that make it particularly useful in the context of Algorithmic Recourse. Firstly, the fact that SCP involves posthoc calibration steps that happen after training, ensures that we need not place any restrictions on the black-box model itself. This stands in contrast to the approach proposed by @schut2021generating in which they essentially restrict the class of models to Bayesian models. Secondly, the fact that the model itself is kept entirely intact ensures that the generated counterfactuals maintain fidelity to the model. Finally, note that we also have not resorted to a surrogate model to learn more about $X \sim \mathcal{X}$. Instead, we have used the fitted model itself and a calibration data set to learn about the model's predictive uncertainty. 

## Counterfactual Explanation

We first wrap our model in a container that makes it compatible with `CounterfactualExplanations.jl`. Then we draw a random sample, determine its predicted label $\hat{y}$ and choose the opposite label as our target. 

```{julia}
M = CCE.ConformalModel(conf_model, mach.fitresult)
x = select_factual(counterfactual_data,rand(1:size(counterfactual_data.X,2)))
y_factual = predict_label(M, counterfactual_data, x)[1]
target = counterfactual_data.y_levels[counterfactual_data.y_levels .!= y_factual][1]
```

The generic Conformal Counterfactual Generator works with the following counterfactual search objective,

$$
x^\prime = \arg \min_{x^\prime}  \ell(M(x^\prime),t) + \lambda \mathbb{I}_{y^\prime = t} \Omega(C_{\theta}(x;\tau)) 
$$ {#eq-solution}

where 

$$
\Omega(C_{\theta}(x;\tau)) = = \max (0, \sum_k C_{\theta,k}(x;\tau) - \kappa)
$$ {#eq-size-loss}

is a smooth size penalty for conformal classifiers introduced by @stutz2022learning. Here, $C_{\theta,k}(x;\tau)$ is loosely defined as the probability that class $k$ is assigned to the conformal prediction set $C$. In the context of Conformal Training, this penalty reduces the **inefficiency** of the conformal predictor. In our context, we are not interested in improving the model itself, but rather in producing **plausible** counterfactuals. Provided that our counterfactual $x^\prime$ is already inside the target domain ($\mathbb{I}_{y^\prime = t}=1$), penalizing $\Omega(C_{\theta}(x;\tau))$ corresponds to guiding counterfactuals into regions of the target domain that are characterized by low ambiguity: for $\kappa=1$ the conformal prediction set includes only the target label $t$ as $\Omega(C_{\theta}(x;\tau))$. Arguably, less ambiguous counterfactuals are more **plausible**. Since the search is guided purely by properties of the model itself and (exchangeable) calibration data, counterfactuals also maintain **high fidelity**.

```{julia}
#| output: true
#| echo: false
#| label: fig-losses
#| fig-cap: "Illustration of the smooth size loss and the configurable classification loss."
temp = 0.5
p1 = contourf(mach.model, mach.fitresult, X, y; plot_set_loss=true, zoom=0, temp=temp)
p2 = contourf(mach.model, mach.fitresult, X, y; plot_classification_loss=true, target=target, zoom=0, temp=temp, clim=nothing, loss_matrix=ones(2,2))
plot(p1, p2, size=(800,320))
```

### Penalizing Size

```{julia}
#| output: true
#| echo: false
#| label: fig-ce
#| fig-cap: "Comparison of counterfactuals produced using different generators."

opt = Descent(0.01)
ordered_names = [
    "Generic (γ=0.5)",
    "Conformal (λ₂=1)",
    "Conformal (λ₂=10)"
]
loss_fun = Objectives.logitbinarycrossentropy
generator = GenericGenerator(opt = opt)

# Generators:
generators = Dict(
    ordered_names[1] => generator,
    ordered_names[2] => deepcopy(generator) |> gen -> @objective(gen, _ + 0.1distance_l2 + 1.0set_size_penalty),
    ordered_names[3] => deepcopy(generator) |> gen -> @objective(gen, _ + 0.1distance_l2 + 10.0set_size_penalty),
)

counterfactuals = Dict([name => generate_counterfactual(x, target, counterfactual_data, M, gen; initialization=:identity, converge_when=:generator_conditions, gradient_tol=1e-3) for (name, gen) in generators])

# Plots:
plts = []
for name ∈ ordered_names
    ce = counterfactuals[name]
    plt = plot(ce; title=name, colorbar=false, ticks = false, legend=false, zoom=0)
    plts = vcat(plts..., plt)
end
_n = length(generators)
img_size = 300
plot(plts..., size=(_n * img_size,1.05*img_size), layout=(1,_n))
```


### Configurable Classification Loss

```{julia}
#| output: true
#| echo: false
#| label: fig-ce
#| fig-cap: "Comparison of counterfactuals produced using different generators."

opt = Descent(0.01)
temp = 0.75
ordered_names = [
    "Generic (γ=0.5)",
    "Generic (γ=0.9)",
    "Conformal (λ₂=1)",
    "Conformal (λ₂=10)"
]
loss_fun = Objectives.logitbinarycrossentropy

# Generators:
generators = Dict(
    ordered_names[1] => GenericGenerator(opt = opt, decision_threshold=0.5),
    ordered_names[2] => GenericGenerator(opt = opt, decision_threshold=0.9),
    ordered_names[3] => CCE.ConformalGenerator(opt=opt, λ=[0.1,1], temp=temp),
    ordered_names[4] => CCE.ConformalGenerator(opt=opt, λ=[0.1,10], temp=temp),
)

counterfactuals = Dict([name => generate_counterfactual(x, target, counterfactual_data, M, gen; initialization=:identity) for (name, gen) in generators])

# Plots:
plts = []
for name ∈ ordered_names
    ce = counterfactuals[name]
    plt = plot(ce; title=name, colorbar=false, ticks = false, legend=false, zoom=0)
    plts = vcat(plts..., plt)
end
_n = length(generators)
img_size = 300
plot(plts..., size=(_n * img_size,1.05*img_size), layout=(1,_n))
```